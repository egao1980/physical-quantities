(in-package :pq)

;; Helper functions -----------------------------------------------------------------

(defun add-errors (&rest errors)
  (let ((sum (loop for err in errors sum (expt err 2))))
    (if (plusp sum) (sqrt sum) 0)))

(defun add-aerr (&rest quantities)
  (apply #'add-errors (loop for q in quantities collect (absolute-error q))))
(defun add-rerr (&rest quantities)
  (- (apply #'add-errors (loop for q in quantities collect (relative-error q)))))

(defmacro dup-quantity (q &key v e u)
  `(make-instance 'quantity
                  :value ,(if (or (null v) (eql q v)) `(value ,q) v)
                  :error ,(if (or (null e) (eql q e)) `(error-direct ,q) e)
                  :unit ,(if (or (null u) (eql q u)) `(copy-tree (unit ,q)) u)))

(defmacro with-unitless-quantity ((val err quantity) &body body)
  (with-gensyms (expansion factor)
    `(multiple-value-bind (,expansion ,factor) (expand-unit (unit ,quantity))
       (when ,expansion
         (error "Quantity is required to be without unit!"))
       (let ((,val (* ,factor (value ,quantity))) (,err (if (minusp (error-direct ,quantity)) (error-direct ,quantity) (* ,factor (error-direct ,quantity)))))
         ,@body))))

;; Actual functions -----------------------------------------------------------------

(defun quantityp (object)
  (eql (type-of object) 'quantity))

(defun copy-quantity (q)
  `(dup-quantity ,q))

(defgeneric binary+ (a b))
(defmethod binary+ ((a quantity) (b quantity))
  (let ((b2 (convert-units b (unit a))))
    (dup-quantity a :v (+ (value a) (value b2)) :e (add-aerr a b))))
(defmethod binary+ ((a number) (b number))
  (+ a b))
(defun q+ (&rest numbers)
  (cond
    ((null numbers) 0)
    ((l= numbers 1) (car numbers))
    (t (reduce #'binary+ numbers))))
(export 'q+)

(defgeneric unary- (a))
(defmethod unary- ((a quantity))
  (dup-quantity a :v (- (value a))))
(defmethod unary- ((a number))
  (- a))
(defgeneric binary- (a b))
(defmethod binary- ((a quantity) (b quantity))
  (let ((b2 (convert-units b (unit a))))
    (dup-quantity a :v (- (value a) (value b2)) :e (add-aerr a b))))
(defmethod binary- ((a number) (b number))
  (- a b))
(defun q- (number &rest more-numbers)
  (cond
    ((null more-numbers) (unary- number))
    (t (binary- number (apply #'q+ more-numbers)))))
(export 'q-)

(defgeneric binary* (a b))
(defmethod binary* ((a quantity) (b quantity))
  (dup-quantity a :v (* (value a) (value b)) :e (add-rerr a b) :u (multiply-units (unit a) (unit b))))
(defmethod binary* ((a number) (b quantity))
  (dup-quantity b :v (* a (value b)) :e (if (plusp (error-direct b)) (* a (error-direct b)) (error-direct b))))
(defmethod binary* ((a quantity) (b number))
  (binary* b a))
(defmethod binary* ((a number) (b number))
  (* a b))
(defun q* (&rest numbers)
  (cond
    ((null numbers) 1)
    ((l= numbers 1) (car numbers))
    (t (reduce #'binary* numbers))))
(export 'q*)

(defgeneric unary/ (a))
(defmethod unary- ((a number))
  (/ a))
(defmethod unary- ((a quantity))
  (make-instance 'quantity :value (/ (value a)) :error (- (rerr a)) :u (power-unit (unit a) -1)))
(defgeneric binary/ (a b))
(defmethod binary/ ((a quantity) (b quantity))
  (dup-quantity a :v (/ (value a) (value b)) :e (add-rerr a b) :u (divide-units (unit a) (unit b))))
(defmethod binary/ ((a number) (b quantity))
  (dup-quantity b :v (/ a (value b)) :e (if (plusp (error-direct b)) (* a (error-direct b) (expt (value b) -2)) (error-direct b)) :u (power-unit (unit b) -1)))
(defmethod binary/ ((a quantity) (b number))
  (dup-quantity a :v (/ (value a) b) :e (if (plusp (error-direct a)) (/ (error-direct a) b) (error-direct a))))
(defmethod binary/ ((a number) (b number))
  (/ a b))
(defun q/ (number &rest more-numbers)
  (cond
    ((null more-numbers) (unary/ number))
    (t (binary/ number (apply #'q* more-numbers)))))
(export 'q/)

(defgeneric qpow (base power))
(defmethod qpow ((base quantity) (power integer))
  (cond
    ((zerop power) (if (/= 0 (value base))
                       (make-instance 'quantity :value 1)
                       (error "Zero raised to the power of zero!")))
    (t (dup-quantity base :v (expt (value base) power) :e (apply #'add-rerr (loop for i below (abs power) collect base)) :u (power-unit (unit base) power)))))
(defmethod qpow ((base number) (power quantity))
  (with-unitless-quantity (val err power)
    (let ((v (expt base val)))
      (make-instance 'quantity :value v :error (abs (* v (log base) (ae val err)))))))
(defmethod qpow ((base quantity) (power quantity))
  (with-unitless-quantity (bval berr base)
    (with-unitless-quantity (pval perr power)
      (when (not (integerp pval))
        (error "Cannot raise quantity to a non-integer power!"))
      (cond
        ((zerop pval) (if (/= 0 bval)
                          (make-instance 'quantity :value 1)
                          (error "Zero raised to the power of zero!")))
        (t (let ((v (expt bval pval)))
             (make-instance 'quantity :value v :error (* (abs v) (sqrt (+ (expt (* (/ pval bval) (ae bval berr)) 2) (expt (* (log bval) (ae pval perr)) 2)))) :unit (power-unit (unit base) pval))))))))
(export 'qpow)

(defgeneric qroot (radicand index))
(defmethod qroot ((radicand quantity) (index integer))
  (when (<= index 0)
    (error "Root index must be greater than zero!"))
  (make-instance 'quantity :value (expt (value radicand) (/ index)) :error (- (/ (rerr radicand) index)) :unit (root-unit (unit radicand) index)))
(export 'qroot)

(defgeneric qexp (quantity))
(defmethod qexp ((q quantity))
  (with-unitless-quantity (val err q)
    (make-instance 'quantity :value (exp val) :error (* (exp val) (ae val err)))))
(export 'qexp)

(defgeneric qln (number))
(defmethod qln ((number quantity))
  (with-unitless-quantity (val err number)
    (make-instance 'quantity :value (log val) :error (abs (/ (ae val err) val)))))
(export 'qln)

(defgeneric qlog (number base))
(defmethod qlog ((q quantity) (base number))
  (with-unitless-quantity (val err base)
    (make-instance 'quantity :value (log val base) :error (abs (/ (ae val err) val (log base))))))
(export 'qlog)
